# This file is double-licensed under GPLv3 and MIT (see LICENSE file)

### Options ###
local OPT_HELP OPT_VERBOSE OPT_QUIET OPT_NOANSI OPT_SYNOPSIS OPT_BLOCKA OPT_BLOCKB OPT_SCOMM OPT_BASH
local -A opthash
zparseopts -E -D -A opthash h -help v -verbose q -quiet r -really-quiet n -noansi -synopsis: -blocka: -blockb: -scomm -bash || {
    echo "Improper options given, see help (-h/--help)"
    return 1
}
(( ${+opthash[-h]} + ${+opthash[--help]} )) && OPT_HELP=-h
(( ${+opthash[-v]} + ${+opthash[--verbose]} )) && OPT_VERBOSE=-v
(( ${+opthash[-q]} + ${+opthash[--quiet]} )) && OPT_QUIET=-q
(( ${+opthash[-r]} + ${+opthash[--really-quiet]} )) && {
    OPT_QUIET=-q
    OPT_RQUIET=-r
}
(( ${+opthash[-n]} + ${+opthash[--noansi]} )) && OPT_NOANSI=-n
(( ${+opthash[--synopsis]} )) && OPT_SYNOPSIS=${opthash[--synopsis]}
(( ${+opthash[--blocka]} )) && OPT_BLOCKA=${opthash[--blocka]}
(( ${+opthash[--blockb]} )) && OPT_BLOCKB=${opthash[--blockb]}
(( ${+opthash[--scomm]} )) && OPT_SCOMM=--scomm
(( ${+opthash[--bash]} )) && OPT_BASH=--bash
[[ -n $OPT_NOANSI ]] && {
    colors=()
    fg=()
    bg=()
    fg_bold=()
    bg_bold=()
    reset_color=
}
if [[ -n $OPT_HELP ]]; then
    usage
fi
    return 0
if [[ $# -le 0 || $* = [[:space:]]## ]]; then
    builtin print -- "zsd-to-adoc: Argument needed, see help (-h/--help)"
    return 1
fi
if [[ ! -f $1 ]]; then
    [[ -z $OPT_QUIET || -n $OPT_VERBOSE ]] && builtin print -- "%F{yellow}Warning: File $1 not found, skipping %f"
    return 1
fi
if [[ ! -r $1 ]]; then
    [[ -z $OPT_QUIET || -n $OPT_VERBOSE ]] && builtin print -- "%F{yellow}Warning: File $1 unreadable, skipping %f"
    return 1
fi

[[ -z $OPT_QUIET ]] && print -P -- "%F{cyan}==>%f zsd-to-adoc 3rd pass - %B%F{green}$(basename ${1})%f%b"

line_count() {
    local -a list
    list=( "${(@f)1}" )
    local count=${#list}
    [[ $1 = *$"\n" ]] && (( -- count ))
    builtin print -- "${count}"
}

local name=${1:t} empty tmp script_body body_comments body nl=$'\n'
local ofname="${name}.adoc" fun
integer len env_vars_count=0 empty_env_vars_count=0
local -a arr
command rm -f -- zsdoc/$ofname
{
    script_body=$(<zsdoc/data/bodies/$name)
    if [[ ${name[1]} = . ]]; then
        builtin print -- " $name(1)"
        len=${#name}+4
        builtin print -- ${(r:len::=:)empty}
    else
        builtin print -- "$name(1)"
        len=${#name}+3
        builtin print -- ${(r:len::=:)empty}
    fi
    builtin print -- ":compat-mode!:"
    builtin print --
    builtin print -- NAME
    if [[ ${name[1]} = "." ]]; then
        builtin print -- ${(r:5::-:)empty}
        builtin print -- " $name - a shell script"
    else
        builtin print -- ${(r:4::-:)empty}
        builtin print -- "$name - a shell script"
    fi
    print
    builtin print -- SYNOPSIS
    builtin print -- ${(r:8::-:)empty}
    if [[ -n $OPT_SYNOPSIS ]]; then
        builtin print -- $OPT_SYNOPSIS
    else
        body_comments=$(<zsdoc/data/bodies/$name.comments)
        body=${(S)body_comments/(#bi)*synopsis*${OPT_BLOCKA:-\{\{\{}(*)${OPT_BLOCKB:-\}\}\}}*/${match[1]}}
        if [[ $body_comments != $body ]]; then
            builtin print -- "${match[1]//((#s)|$nl)[[:blank:]]#\#[[:blank:]]#/$nl}"
        else
            builtin print -- 'Documentation automatically generated with zshelldoc'
        fi
    fi
    print
    builtin print -- 'FUNCTIONS'
    builtin print -- "${(r:9::-:)empty}"
    print
    local -a funs hooks
    funs=(zsdoc/data/functions/$name/*(DN))
    funs=("${funs[@]:t}")
    hooks=(zsdoc/data/hooks/$name/*(DN))
    hooks=("${hooks[@]:t}")
    for fun in "${funs[@]}"; do
        if [[ -n ${hooks[(r)$fun]} ]]; then
            continue
        else
            builtin print -- " $fun"
        fi
    done
    funs=(zsdoc/data/autoload/$name/*(DN))
    funs=("${funs[@]:t}")
    for fun in "${funs[@]}"; do
        builtin print -- "AUTOLOAD ${fun}"
    done
    for fun in "${hooks[@]}"; do
        builtin print -- ${(U)$(<zsdoc/data/hooks/$name/$fun)}-HOOK $fun
    done
    local work_comments=$body_comments
    local env_desc=${(S)work_comments/(#bi)*env-vars*${OPT_BLOCKA:-\{\{\{}(*)${OPT_BLOCKB:-\}\}\}}/${match[1]}}
    integer fixed_envs_offset=0
    local -a fixed_env_descs
    while [[ $work_comments != $env_desc ]]; do
        local -a sorted
        sorted=("${(@s:->:)match[1]}")
        integer sidx ssize=${#sorted}
        for ((sidx=2; sidx <= ssize; ++ sidx )); do
            if [[ ${sorted[sidx-1]} = (#b)*((#s)|$nl)([^$nl]#)(#e) ]]; then
                fixed_env_descs[fixed_envs_offset+(sidx-1)*2-1]="${${match[2]##\#[[:space:]]#}%%[[:space:]]#}"
                fixed_env_descs[fixed_envs_offset+(sidx-1)*2]=${sorted[sidx]}
                (( sidx > 2 )) && fixed_env_descs[fixed_envs_offset+(sidx-2)*2]="${fixed_env_descs[fixed_envs_offset+(sidx-2)*2]%${match[2]}}"
            fi
        done
        (( ssize >= 2 )) && env_vars_count+=1  || empty_env_vars_count+=1
        ssize=${#fixed_env_descs}
        for ((sidx=fixed_envs_offset+1; sidx <= ssize; ++ sidx )); do
            fixed_env_descs[sidx]="${${${fixed_env_descs[sidx]//((#s)|$nl)[[:blank:]]#\##[[:blank:]]#/$nl}%$nl}#$nl}"
        done
        fixed_envs_offset=${#fixed_env_descs}
        work_comments=$env_desc
        env_desc=${(S)work_comments/(#bi)*env-vars*${OPT_BLOCKA:-\{\{\{}(*)${OPT_BLOCKB:-\}\}\}}(*)/${match[1]}}
    done

    if (( ${#fixed_env_descs} > 0 )); then
        local -A fixed_env_descs_hash
        fixed_env_descs_hash=("${fixed_env_descs[@]}")

        print -l -- "" \
          "ENVIRONMENT VARIABLES" \
          "${(r:21::-:)empty}" \
          '[width="80%",cols="4,10"]'

        builtin print -- '|======'
        local key
        for key in "${(kon)fixed_env_descs_hash[@]}"; do
            builtin print -- "|$key|${fixed_env_descs_hash[$key]}"
        done
        builtin print -- '|======'
    fi

    print
    builtin print -- "DETAILS"
    builtin print -- "${(r:7::-:)empty}"
    print

    [[ -f zsdoc/data/bodies/$name ]] && {
        print -l -- "Script Body" "${(r:11::~:)empty}" ""

        [[ -f zsdoc/data/trees/$name/Script_Body_.tree ]] && {
            print -l -- "Has $(line_count $script_body) line(s). Calls functions:"
            print
            arr=("${(@f)"$(<zsdoc/data/trees/$name/Script_Body_.tree)"}")
            [[ ${#arr} -ge 3 ]] && {
              arr=("${(@)arr[1,-3]}")
            }
            arr=("${arr[@]/Script_Body_/Script-Body}")
            arr=("${arr[@]/(#s)/ }")
            builtin print -- "${(F)arr}"
        } || {
            if [[ -n $OPT_BASH ]]; then
                builtin print -- "Has `line_count $script_body` line(s). No functions are called (may set up e.g. command_not_found_handle or call a function indirectly in other way)."
            else
                builtin print -- "Has `line_count $script_body` line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.)."
            fi
        }
        print
        local -a features
        features=(zsdoc/data/features/$name/Script_Body_/*(DN))
        features=("${(@)features#zsdoc/data/features/$name/Script_Body_/}")
        if [[ ${#features} -gt 0 ]]; then
            builtin print -- "Uses feature(s): _${(oj:_, _:)features}_"
            print
        fi
        local -a exports
        exports=(zsdoc/data/exports/$name/Script_Body_/*(DN))
        exports=("${(@)exports#zsdoc/data/exports/$name/Script_Body_/}")
        if [[ ${#exports} -gt 0 ]]; then
            builtin print -- "_Exports (environment):_ ${(oj: [big]*//* :)exports}"
            print
        fi
    }
    funs=(zsdoc/data/functions/$name/*(DN) zsdoc/data/autoload/$name/*(DN))
    funs=("${funs[@]:t}")
    for fun in "${funs[@]}"; do
        builtin print -- "$fun"
        len=${#fun}
        builtin print -- "${(r:len::~:)empty}"
        print
        [[ -f zsdoc/data/descriptions/$name/$fun ]] && {
            zsd-trim-indent "$(<zsdoc/data/descriptions/$name/$fun)"
            [[ -n $OPT_SCOMM ]] && REPLY="${REPLY//((#s)|$nl)[[:blank:]]#\#[[:blank:]]#/$nl}"
            arr=("${(@f)REPLY}")
            [[ ${arr[-1]} = [[:space:]]#\#[[:space:]]# ]] && arr[-1]=()
            arr=("${arr[@]/(#s)/ }")
            builtin print -- '____'
            print -l -- "${arr[@]}"
            builtin print -- '____'
            print
        }
        {
            body=$(<zsdoc/data/functions/$name/$fun)
        } 2> /dev/null
        [[ -z $body ]] && body=$(<zsdoc/data/autoload/$name/$fun)
        [[ -f zsdoc/data/trees/$name/$fun.tree ]] && {
            arr=("${(@f)"$(<zsdoc/data/trees/$name/$fun.tree)"}")
            [[ ${#arr} -ge 3 ]] && arr=("${(@)arr[1,-3]}")
            arr=("${arr[@]/Script_Body_/Script-Body}")
            arr=("${arr[@]/(#s)/ }")
            if [[ -n ${hooks[(r)$fun]} ]]; then
                builtin print -- "Has $(line_count $body) line(s). *Is a $(<zsdoc/data/hooks/$name/$fun) hook*. Calls functions:"
            else
                builtin print -- "Has $(line_count $body) line(s). Calls functions:"
            fi
            print
            builtin print -- "${(F)arr}"
        } || {
            if [[ -n ${hooks[(r)$fun]} ]]; then
                builtin print -- "Has $(line_count $body) line(s). *Is a $(<zsdoc/data/hooks/${name}/${fun}) hook*. Calls no other functions"
            else
                builtin print -- "Has $(line_count ${body}) line(s). Calls no functions"
            fi
        }
        print
        local -a features
        features=(zsdoc/data/features/$name/$fun/*(DN))
        features=("${(@)features#zsdoc/data/features/$name/$fun/}")
        if [[ ${#features} -gt 0 ]]; then
            builtin print -- "Uses feature(s): _${(oj:_, _:)features}_"
            print
        fi
        arr=(zsdoc/data/trees/$name/*/$fun(DN) zsdoc/data/trees/*/*/*_-_$fun(DN))
        if [[ ${#arr} -eq 0 ]]; then
            if [[ -n $OPT_BASH ]]; then
                builtin print -- "Not called by script or any function (may be e.g. command_not_found_handle or called indirectly in other way)."
            else
                builtin print -- "Not called by script or any function (may be e.g. a hook, a Zle widget, etc.)."
            fi
            print
        else
            builtin print -- "Called by:"
            print
            arr=("${arr[@]#zsdoc/data/trees/$name/}")
            arr=("${arr[@]#zsdoc/data/trees/}")
            arr=("${arr[@]%/*}")
            arr=("${arr[@]//_-_//}")
            arr=("${arr[@]/Script_Body_/Script-Body}")
            arr=("${(u)arr[@]}")
            print -rl -- "${arr[@]/(#s)/ }"
            print
        fi
        local -a exports
        exports=(zsdoc/data/exports/$name/$fun/*(DN))
        exports=("${exports[@]#zsdoc/data/exports/$name/$fun/}")
        if [[ ${#exports} -gt 0 ]]; then
            builtin print -- "_List of exports (to environment):_ ${(oj: [big]*//* :)exports}"
            print
        fi
        local -a env_uses
        env_uses=(zsdoc/data/env-use/$name/$fun/*/*/*(DN))
        env_uses=("${env_uses[@]#zsdoc/data/env-use/$name/$fun/}")
        env_uses=("${env_uses[@]//(#b)([^\/]##)\/[^\/]##\/(*)/${match[1]} -> ${match[2]}}")
        env_uses=("${env_uses[@]/$name -> /}")
        if [[ ${#env_uses} -gt 0 ]]; then
            builtin print -- "_Environment variables used:_ ${(oj: [big]*//* :)env_uses}"
            print
        fi
    done
} >>| zsdoc/$ofname

[[ -z $OPT_QUIET ]] && print -P -- "%F{blue}==>%f Found %B%F{green}env_vars_count%f%b env-vars sections ${${empty_env_vars_count:#0}:+ (+$empty_env_vars_count empty ones)}"
[[ -z $OPT_QUIET ]] && print -P -- "%F{blue}==>%f asciidoc saved to %B%F{green}zsdoc/${ofname}%f%b"

return 0

# vim: set expandtab filetype=zsh shiftwidth=2 softtabstop=2 tabstop=2:
